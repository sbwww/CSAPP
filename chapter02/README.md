信息的表示和处理

![](bits.jpg)

## 1. Intro

### 1.1. 二进制容易表示和传输，电路简单可靠

### 1.2. 整数运算和浮点运算

- 优点
  | | 整数 | 浮点 |
  | :---: | :------------: | :----------: |
  | 范围 | 小 | 大 $\sqrt{}$ |
  | 精度 | 精确 $\sqrt{}$ | 近似 |

- 数学属性不同，因为他们处理数字表示有限性的方式不同
  - 浮点运算不能结合
    | $3.14+1e20-1e20$ | $3.14+(1e20-1e20)$ |
    | :--------------: | :----------------: |
    | $0$ | $3.14$ |

## 2. 信息存储

### 2.1. 16 进制

- 为什么是 16？
  - 1 位 16 进制 = 4 位 2 进制
  - 2 位 16 进制 = 1 字节 Byte
- 10 进制和 16 进制直接的转换（Python）
  - [10->16](d2h.py)
  - [16->10](h2d.py)

### 2.2. C 语言数据类型

|   类型    | 32 位 | 64 位 |
| :-------: | :---: | :---: |
|   char    |   1   |   1   |
|   short   |   2   |   2   |
|  ==int==  | ==4== | ==4== |
|   long    |   4   |   8   |
| long long |   8   |   8   |
| ==T \*==  | ==4== | ==8== |
|   float   |   4   |   4   |
|  double   |   8   |   8   |

[type_len.c](type_len.c)

### 2.3. 要让程序对不同数据类型的确切大小不敏感，这样有更好的移植性

- 32 位系统把指针值赋给 int 是可以的
  指针 4 -> int 4
- 但是到了 64 位系统中会导致问题
  指针 8 -> int 4

### 2.4. 大端 vs 小端

```c
int x = 0x01234567
&x == 0x100
```

|                       | 0x100 | 0x102 | 0x103 | 0x104 |
| :-------------------: | :---: | :---: | :---: | :---: |
| 大端 最高有效字节在前 |  01   |  23   |  45   |  67   |
| 小端 最低有效字节在前 |  67   |  45   |  23   |  01   |

> 一般使用小端

### 2.5. 使用强制类型转换来访问不同程序对象的字节表示

[show-bytes.c](show-bytes.c)

```shell
✗ ./show-bytes  1234
 39 30 00 00
 00 e4 40 46
 2c 5b c9 5b ff 7f 00 00
```

### 2.6. 文本数据比二进制具有更强的平台独立性

因为字符串的表示本身做了抽象，字符串总是从始址开始到终止字节（0x00）结束，与字节顺序和字大小规则无关

如，show_bytes("12345", 6) 得到结果 31 32 33 34 35 00

### 2.7. 练习题 2.7 下面的输出结果是 0x61-0x66, 没用 00，因为 strlen 不计最后的 \0

```c
const char *s = "abcdef";
show_bytes((byte_pointer)s, strlen(s));
```

### 2.8. 查看机器代码，二进制代码是不兼容的（hexdump sum.o）

[sum.c](sum.c)

在我的 mac 64 是：00001d0 55 48 89 e5 89 7d fc 89 75 f8 8b 75 fc 03 75 f8

### 2.9. 位向量 位运算

将多位 0-1 值组成向量，两个位向量的运算就是对应位逐个运算

> 一个很有用的应用
> 表示有限集合，某位为 1 表示对应的元素存在
> 可以将状态压缩为一个整数

```c
1 << S  // S 个元素的集合，2^S 种子集状态
```

### 2.10. 习题 2.10

对任何一个向量 a, a^a = 0， 应用这一属性，有下面的 swap 程序

[inplace_swap.c](inplace_swap.c)

不使用中间变量，也没有性能上的优势，仅仅是智力游戏

```c
*y = *x ^ *y;  // y <- x^y
*x = *x ^ *y;  // x <- x^(x^y) = y
*y = *x ^ *y;  // y <- y^(x^y) = x
```

### 2.11. 习题 2.11

承上题，利用上面的 swap 函数实现对调一个数组的元素，源程序的问题是对中间元素自身异或自身得到 0

原因是：当长度为奇数时，会出现 first==last 的情况，此时 `inplace_swap(&a[first], &a[last])` 接收了两个相同的指针，函数中的 x 和 y 都是中间的值

解决方法：把 for 循环条件中的 `first <= last;` 改为 `first < last;`

[reverse_array.c](reverse_array.c)

### 2.12. 位运算的常见应用

> 掩码运算
> 掩码是一个位模式。

使用 ~0 得到全 1 的掩码，而非使用 0XFFF$\cdots$F，考虑移植性（不确定 F 的位数，但是~0 是通用的）

### 2.13. 习题 2.13 只有 bis 和 bic 实现位设置和清除，而不使用其他 C 语言运算，实现位级|和^运算

理清题意：bis(x,m)对 m 的为 1 的位对 x 置 1，对应地，bic 对应的 位置 0

异或的性质：x ^ y = (x & ~y) | (~x & y)

[bis_bic.c](bis_bic.c)

### 2.14. 左移 & 右移

- **左移**都**一样**，直接补零
- **有符号数**使用**算术右移**，补符号位
- **无符号数**使用**逻辑右移**，直接补零

> Java 中可以明确指定：
> `>>` 为算术
> `>>>` 为逻辑

[Shift.java](Shift.java)

### 2.15. 移位运算优先级

在 C 中，加法比移位运算优先级高

```c
(1 << 2) + (3 << 4) == 52
1 << 2 + 3 << 4 == (1 << (2 + 3)) << 4 == 512
```

不确定就加括号

## 3. 整数表示

### 3.1. 二进制的表示法

原码 $B2U_w$ (Binary to Unsigned)
补码 $B2T_w$ (Binary to Two's-complement)
都是双射函数，相应的数和二进制向量唯一映射

### 3.2. 可移植性

C 语言标准没有要求用补码表示有符号整数，但是几乎所有的机器都是这么做的。

保证最大移植性的做法是利用 limits.h 中的典型取值范围 INT_MAX，INT_MIN，UINT_MAX

### 3.3. 有符号数和无符号数强制类型转换

结果的每一位保持不变，但是改变了解释这些位的方式

[unsigned_cast.c](unsigned_cast.c)

### 3.4. 理解有符号数和无符号数强制类型转化之间的数学关系

![](t2u.jpg)

### 3.5. C 语言中的有符号数和无符号数

- 默认有符号，无符号数要加 `u`，如 `12345u`
- printf 没用任何类型信息，可以用 %d 输出 unsigned 类型，也可以用 %u 输出 int 类型
  [printf_no_type.c](printf_no_type.c)
- 运算表达式中如果一个是有符号数一个是无符号数，则会隐式的将**有**符号**转换为无**符号
  对标准算术运算可能差异不大，但是对于 `>` 或 `<` 等**关系运算**就要注意了

  ```c
  -1 > 0U  // 实际上是 UMAX > 0U
  ```

  [type_cast_op.c](type_cast_op.c)

### 3.6. 提升数据类型（位扩展）

- 无符号数
  零扩展，在前面补 0
- 有符号数
  符号扩展，在前面补最高位的值

[zero_sign_extension.c](zero_sign_extension.c)
小端输出 `x = -12345: c7 cf ff ff`
大端输出 `x = -12345: ff ff cf c7`

#### 3.6.1. 证明符号扩展的正确性, 利用数学归纳法，证明一位扩展正确即可

![](sign_extension_prove.jpg)

#### 3.6.2. C 语言标准：把 short 转换成 unsigned 时，先改变大小再完成从有符号到无符号的转换。 short -> int -> unsigned

```c
short sx = -12345;
unsigned uy = sx;  // (unsigned)(int) sx
unsigned uz = (unsigned)(unsigned short)sx;
```

[type_cast_mystery.c](type_cast_mystery.c)

### 3.7. 截断

> 溢出的一种形式

- 无符号数
  丢弃高位 相当于 $mod \ 2^k$
- 有符号（补码）
  丢弃高位，并把最高位改成符号位

### 3.8. 关于有无符号的建议

> 有符号和无符号的运算，会隐式转换成**无符号**

习题 2.25
[0U-1.c](0U-1.c)

习题 2.26
[size_t_strlen.c](size_t_strlen.c)

## 4. 整数运算

### 4.1. 习题 2.25 问题在于无符号运算, 0U - 1 = UMax, 然后访问非法地址，coredump

[sum_elements.c](sum_elements.c)

### 4.2. 习题 2.26 问题仍然是无符号运算的微妙，size_t 定义为 unsigned int. 在做差和比较时会采用无符号运算，如果 a<b, a-b 是负数，会成为一个很大的无符号数，所以结果不正确

[stronger.c](stronger.c)

### 4.3. 无符号加法可以视为模数运算，溢出的最高一位丢弃。判断是否无符号相加是否发生了 overflow，就看是否结果反而结果变小了

[uadd_ok.c](uadd_ok.c)

### 4.4. 阿贝尔群（Abelian group）的概念，无符号数的加法逆元 P56

看到这里我滋生了对**无符号数减法**的一点认识，比如 0U-1U = UMax 怎么理解呢？拿具体的无符号 3-4，假设字长为 4bit，一方面我们可以从比特级别来解释所有，
-4 就是补码形式 1100, 只不过现在我们把他看成无符号数，那么 1100 + 0011 = 1111 = 15； 另一方面既然是无符号数相加，那么加上 2 ^ w 自然不会有副作用吧，
所以我们加上一个元 3-4 + 2^4 = 3+16-4=15, 殊途同归，似乎有那么点意思。

### 4.5. 判断补码加法的溢出

[tadd_ok.c](tadd_ok.c), 无论是否溢出 x + y - x == y

### 4.6. 在任何时候都要考虑 Max， Min 这些临界情况，比如 INT_MIN 的逆元就是其自身

习题 2.32 [tsub_ok.c](tsub_ok.c) , 问题在于 当 y=INT_MIN， -y=INT_MIN， x>0, 使用 tadd_ok 自然发现俩异号，不会溢出，但是 x - y 就会发生溢出（上溢）

其实不要把逆元现象的太复杂，其实就是用那个模值-元素，比如假设字长 4bit，求 TMin 得逆元，从 bit 级别上很容易理解 10000 - 1000 = 1000 ，所以 TMin 保持不变

### 4.7. 理解加法逆元的哲学，对补码的逆就是补码的非 negation

![](additive_inverse.jpg)

### 4.8. 乘法运算的位级表示都是一样的，相乘，然后只截断为 w，进而解释为无符号或补码形式，这样机器级的指令只需要一种，同构

### 4.9. 习题 2.35 判断乘法是否溢出

[tmult_ok.c](tmult_ok.c)

### 4.10. C 编译器使用以移位 加法 减法来消除很多乘以常数的情况来减小计算代价

## 5. 浮点数

### 5.1. IEEE754

vonzhou 2016.3.5 下午 HUST 图书馆
